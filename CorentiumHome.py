class CorentiumHome:
    import time
    PAYLOAD_LOCATION = 0xFD80 #there is 128 bytes of free space here to load executable payloads
    
    def __init__(self, ser):
        self.ser = ser
        self.ser.read(256) #flush away any residual junk
        pass

    def crc16(self, data_array):
        crc = 0
        for i in range(len(data_array)):
            crc = crc ^ ((data_array[i] << 8) & 0xffff)
            for i in range(8):
                if (crc & 0x8000 != 0):
                    crc = (crc << 1) ^ 0x1021
                else:
                    crc = crc << 1
                crc &= 0xffff
        return crc

    def ios_write(self, addr):
        assert addr <= 0xffff
        addr = int('{:016b}'.format(addr)[::-1], 2) #reverse the order
        for i in range(16):
            if (addr >> i) & 1 == 1:
                self.ser.write(b'i')
            else:
                self.ser.write(b'o')

    def read_from_flash(self, address):
        #m command
        print("reading from flash")
        self.ser.write(b';')
        self.ios_write(address)
        self.ser.write(b'm')
        read_data = self.ser.read(128)

        status = self.ser.read(16) #m command gives us 16 bytes from 0x370

        read_address = (status[1] << 8) | status[0]
        crc = (status[3] << 8) | status[2]
        rx_byte_idx = status[4]
        last_rx_byte = status[8]
        flags = (status[11] << 8) | status[10]
        tx_byte_idx = status[14]

        assert address == read_address
        assert crc == self.crc16(read_data)
        assert last_rx_byte == ord('m')
        print("crc:", hex(crc))
        print("rx_byte_idx:", rx_byte_idx)
        print("tx_byte_idx:", tx_byte_idx)
        print('flags:', hex(flags))
        return read_data
    
    def write_to_flash(self, payload, address = None):
        #w command
        #this can only be run once per device reset - subsequent calls will be unsucessful. the reason is not clear
        if address is None:
            address = self.PAYLOAD_LOCATION

        print("writing to flash")
        self.ser.write(b'!') #clear rx buffer index
        self.ser.write(payload) #write our 128 byte payload
        self.ser.write(b';') #clear uart ptr
        self.ios_write(self.crc16(payload))
        self.ser.write(b';') #register crc and clear uart ptr
        self.ios_write(address) #our target region of choice in flash
        self.ser.write(b'w') #trigger the flash write operation

        status = self.ser.read(16) #w command gives us 16 bytes from 0x370

        #print(status)
        written_address = (status[1] << 8) | status[0]
        crc = (status[3] << 8) | status[2]
        rx_byte_idx = status[4]
        last_rx_byte = status[8]
        flags = (status[11] << 8) | status[10]
        tx_byte_idx = status[14]

        print("crc:", hex(crc))
        print("rx_byte_idx:", rx_byte_idx)
        print("tx_byte_idx:", tx_byte_idx)
        print('flags:', hex(flags))

        assert address == written_address
        assert crc == self.crc16(payload)
        assert last_rx_byte == ord('w')

    def read_mem_payload(self):
        '''
        This payload is a short sequence to read arbitrary memory and send it back to the UART.
        Usage can be found inside read_arbitrary_address() function

        The binary was generated by compiling the below C code using
        msp430-elf-gcc -c -Os payload.c

        Hex binary was extracted using:
        msp430-elf-objdump -s payload.o

        #include <stdint.h>
        #define TXIFG (1 << 1)
        void payload(void)
        {
            //regs
            volatile uint8_t* UCA0TXBUF = (uint8_t*) 0x67;
            volatile uint8_t* IE1 = (uint8_t*) 0x0;
            volatile uint8_t* IE2 = (uint8_t*) 0x1;
            volatile uint8_t* IFG2 = (uint8_t*) 0x3;

            //vars
            uint16_t* flags = (uint16_t*) 0x37a;
            uint16_t** rx_buffer = (uint16_t**) 0x2e0; //user can write the desired address to read inside the rx buffer

            while(!(*IFG2 & TXIFG));  //make sure is UART idle
            *UCA0TXBUF = **rx_buffer; //double dereference and write the lower byte to UART
            while(!(*IFG2 & TXIFG));  //wait for UART to complete

            *flags &= ~(uint16_t)0x800; //clear bit 11 inside flags to restore

            *IE1 = 0x32; //restore interrupts to default value
            *IE2 = 129;
        }
        '''

        payload = bytes.fromhex('e2b3030000241c42e002e24c6700e2b303000024b2f0fff77a03f24032000000f24081ff01003041')
        payload += b"\0" * (128 - len(payload)) #zero pad to 128 bytes
        return payload

    def execute_payload(self, address = None):
        #X command
        if address is None:
            address = self.PAYLOAD_LOCATION
        self.ser.write(b';') #clear uart ptr
        self.ios_write(0x281e) #magic key needed for execution
        self.ser.write(b';') #register magic key
        self.ios_write(address) #set the location to execute code from
        self.ser.write(b'X') #trigger the flash write operation

    def read_arbitrary_address_byte(self, address):
        #calls the read_mem payload to return one byte from any requested address
        assert address <= 0xffff
        
        self.ser.write(b'!') #clear the buffer
        buffer = bytearray(128)
        buffer[0] = address & 0xff #lower byte
        buffer[1] = address >> 8 #upper byte
        self.ser.write(buffer)
        self.execute_payload(self.PAYLOAD_LOCATION)

        response = self.ser.read(1)
        assert len(response) == 1
        self.time.sleep(0.5) #there is a 500ms delay in the device at this point
        return response[0]
    
    def read_arbitrary_address_short(self, address):
        assert address % 2 == 0 #shorts should be aligned
        return self.read_arbitrary_address_byte(address+1) << 8 | self.read_arbitrary_address_byte(address)

    
if __name__ == "__main__":
    import serial
    ser = serial.Serial('/dev/ttyACM2', timeout=1, baudrate=4800) # open serial port
    radon = CorentiumHome(ser)
    
    payload = radon.read_mem_payload()
    radon.write_to_flash(payload)

    #confirm payload was written successfully
    assert radon.read_from_flash(radon.PAYLOAD_LOCATION) == payload

    print(hex(radon.read_arbitrary_address_short(0x3e4)))
